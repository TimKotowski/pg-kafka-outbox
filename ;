package outbox

import (
	"crypto/tls"
	"time"
)

type Config struct {
	//////////////////////
	// OUTBOX QUEUE SECTION //
	//////////////////////

	// Interval rate for polling outbox messages.
	PollInterval time.Duration

	// Interval rate for requeueing hanging/stalled outbox messages.
	StalledInterval time.Duration

	// Limit for fetching outbox messages
	FetchLimit int

	// This ensures at-most-once processing semantics per kafka key,
	// while preserving processing order for messages with the same key.
	//
	// Enable to prevent multiple workers from processing messages with the same key concurrently.
	// And ensuring messages that are already being processing must finish before
	// more messages with same keys can be retrieved, or if timeout occurs.
	//
	// At most 10 keys and 10 messages per key can be retrieved.
	//
	// If ordering semantics at the time of enqueueing messages art a per kafka key is important
	// Enable this option to ensure only on worker can procress a key at any given time.
	KafkaSingleKeyProcessing bool

	// Enables deduplication of Kafka records based on (key, payload, and topic).
	// When enabled, this setting ensures that exactly once processing of Kafka record
	// with the same key, payload, and topic is allowed in the queue at any given time.
	// Enable this option if deduplication of Kafka records is important for your processing logic.
	// Pairing with EnableSingleKeyProcessing achieves stronger exactly-once semantics by
	// combining deduplication with ordered execution, reducing the risk of reprocessing the same record.
	KafkaRecordDeduplication bool

	// The number of outbox messages to buffer.
	// Defaults to 256.
	ChannelBufferSize int

	/////////////////////
	// GENERAL SECTION //
	/////////////////////

	DSN string

	TLSConfig *tls.Config
}

type ConfigFunc func(c *Config)

func NewConfig(opts ...ConfigFunc) *Config {
	c := &Config{
		PollInterval:             time.Duration(5) * time.Second,
		StalledInterval:          time.Duration(2) * time.Minute,
		KafkaSingleKeyProcessing: false,
		KafkaRecordDeduplication: false,
	}

	for _, opt := range opts {
		opt(c)
	}

	return c
}

func WithJobPollInterval(interval time.Duration) ConfigFunc {
	return func(c *Config) {
		c.PollInterval = interval
	}
}

func WithJobStallPollInterval(interval time.Duration) ConfigFunc {
	return func(c *Config) {
		c.StalledInterval = interval
	}
}

func WithMaxJobSize(size int) ConfigFunc {
	return func(c *Config) {
		c.FetchLimit = size
	}
}

func WithDSN(dsn string) ConfigFunc {
	return func(c *Config) {
		c.DSN = dsn
	}
}

func WithTLSConfig(tlsConfig *tls.Config) ConfigFunc {
	return func(c *Config) {
		c.TLSConfig = tlsConfig
	}
}

func WithKafkaSingleKeyProcessing(exactlyOnceKeyProcessing bool) ConfigFunc {
	return func(c *Config) {
		c.KafkaSingleKeyProcessing = exactlyOnceKeyProcessing
	}
}

func WithKafkaRecordDeduplication(exactlyOnceRecordProcessing bool) ConfigFunc {
	return func(c *Config) {
		c.KafkaRecordDeduplication = exactlyOnceRecordProcessing
	}
}
